import pandas as pd
import utils.utils as ut


class CheckTecDataset:
    def __init__(self):
        """
            Represents an initialization function that loads a configuration file
            into the `config` attribute upon creation of the instance. The function
            utilizes a utility function `load_config` from the `ut` module and
            expects a specific configuration filename passed as an argument.

            Attributes:
                config: Loaded configuration data generated by the
                    `ut.load_config('gen_dataset_config')` function.
        """
        self.config = ut.load_config('gen_dataset_config')

    def apply_corrections(self, df):
        """
            Apply corrections to the given DataFrame based on specified configuration.

            This method processes a DataFrame to modify or correct its content according to
            predefined correction methods specified in the configuration. The corrections are
            applied in sequential order: forward filling, backward filling, moving average, and
            marking incomplete days. If a specific correction method is disabled in the configuration,
            it will be skipped.

            Parameters:
                df (pandas.DataFrame): Input data to be corrected.

            Returns:
                pandas.DataFrame: Corrected DataFrame after applying enabled correction methods.
        """
        if self.config["correction_methods"].get("forward_fill", False):
            df = self.forward_fill(df)
        if self.config["correction_methods"].get("backward_fill", False):
            df = self.backward_fill(df)
        if self.config["correction_methods"].get("moving_average", False):
            df = self.moving_average(df)
        if self.config["correction_methods"].get("mark_incomplete_days", False):
            df = self.mark_incomplete_days(df)

        return df

    def calculate_missing_indicators(self, df):
        """
            Calculates missing indicators for a DataFrame based on configuration settings.

            This method applies specific financial indicators such as SMA, RSI, and MACD
            to the provided DataFrame if they are enabled in the configuration. The
            specific periods for each indicator are predefined and processed conditionally.

            Parameters
            ----------
            df : DataFrame
                A pandas DataFrame that contains the data to which the indicators will
                be applied.

            Returns
            -------
            DataFrame
                The updated DataFrame with the calculated indicators applied.

            Raises
            ------
            Exception
                If any calculation process fails or encounters invalid input data.
        """
        if self.config["calculate_indicators"].get("sma", False):
            for period in [5, 10, 12]:
                df = self.calculate_sma_partial(df, period)

        if self.config["calculate_indicators"].get("rsi", False):
            for period in [5, 7, 9]:
                df = self.calculate_rsi_partial(df, period)

        if self.config["calculate_indicators"].get("macd", False):
            df = self.calculate_macd_partial(df)

        return df

    def apply_date_time_actions(self, df):
        """
            apply_date_time_actions(df)

            Apply various date-time related actions to the given dataframe based on the configuration
            provided. The method processes the dataframe using predefined actions such as splitting
            dates, filling missing time intervals, or adding temporal features. Each action is performed
            conditionally based on the configuration settings.

            Parameters:
                df (DataFrame): The input dataframe on which date-time actions are to be applied.

            Returns:
                DataFrame: The processed dataframe after applying the selected date-time actions.
        """
        if self.config["date_time_actions"].get("date_split", False):
            df = self.split_date(df)

        if self.config["date_time_actions"].get("fill_missing_days", False):
            df = self.fill_missing_days(df)

        if self.config["date_time_actions"].get("fill_missing_hours", False):
            df = self.fill_missing_hours(df)

        if self.config["date_time_actions"].get("add_temporal_features", False):
            df = self.add_temporal_features(df)

        return df

    @staticmethod
    def forward_fill(df):
        """
            Forward fill missing data in a DataFrame.

            This static method fills missing values in a given DataFrame by carrying
            forward the last valid observation along each column. This can be useful
            for preparing datasets where missing values need to be replaced for
            continuation of analysis.

            Args:
                df (pandas.DataFrame): The input DataFrame with potential missing values.

            Returns:
                pandas.DataFrame: A DataFrame where missing values have been filled using
                forward fill method.
        """
        return df.fillna(method="ffill")

    @staticmethod
    def backward_fill(df):
        """
            This method backward fills NaN values in a DataFrame, working from the next valid
            observation toward the end of the data. The function is useful in scenarios where
            missing values should be replaced with the next non-missing value.

            Args:
                df (DataFrame): The input pandas DataFrame containing NaN values
                                to be filled. The method assumes that the input
                                DataFrame is properly formatted and structured for
                                filling operations.

            Returns:
                DataFrame: A DataFrame with NaN values replaced using backward fill.
        """
        return df.fillna(method="bfill")

    @staticmethod
    def moving_average(df):
        """
            A utility method to compute the moving average for numeric columns in a
            DataFrame. The moving average is calculated using a rolling window of size
            5, with a minimum of one period. Non-numeric columns are not modified.

            Args:
                df (DataFrame): The input pandas DataFrame to process.

            Returns:
                DataFrame: A pandas DataFrame with the moving average applied to numeric
                columns, while non-numeric columns remain unaltered.
        """
        return df.apply(
            lambda col: col.fillna(col.rolling(window=5, min_periods=1).mean())
            if col.dtype in [float, int] else col
        )

    def mark_incomplete_days(self, df):
        """
            Marks and removes incomplete days in the provided DataFrame.

            This function identifies rows with any missing values in the given DataFrame
            and marks them by adding a new column "is_incomplete". It then removes these
            incomplete records from the DataFrame.

            Args:
                df (pandas.DataFrame): The DataFrame to be processed.

            Returns:
                pandas.DataFrame: A new DataFrame with incomplete records removed and
                marked.

            Raises:
                None
        """
        df["is_incomplete"] = df.isnull().any(axis=1)
        df = self.remove_incomplete_records(df)
        return df

    @staticmethod
    def calculate_sma_partial(df, period, column="close"):
        """
            Calculates the Simple Moving Average (SMA) for the specified period on a given column
            in the DataFrame. If the SMA column for the given period does not already exist, it
            will create and compute it. Updates the missing entries in the SMA column with
            calculated SMA values and rounds the result to four decimal places.

            Args:
                df (pd.DataFrame): The DataFrame containing the data to calculate the SMA on.
                period (int): The number of periods to use for the rolling SMA calculation.
                column (str): The name of the column to calculate the SMA on. Defaults to "close".

            Returns:
                pd.DataFrame: A DataFrame with the SMA column updated or created.
        """
        sma_column = f"sma_{period}"
        if sma_column not in df.columns:
            df[sma_column] = pd.NA

        sma_series = df[column].rolling(window=period, min_periods=1).mean()
        df.loc[df[sma_column].isnull(), sma_column] = sma_series[df[sma_column].isnull()]
        df[sma_column] = df[sma_column].round(4)
        return df

    @staticmethod
    def calculate_rsi_partial(df, period, column="close"):
        """
            Calculates the Relative Strength Index (RSI) values for a specified period and appends the results
            to a provided DataFrame. The method computes RSI using the gain and loss of the data over a
            rolling window. It ensures the calculated RSI values are only updated for rows where the RSI column is
            initially empty. The resulting RSI values are rounded to four decimal places and reflected in a new
            column named according to the RSI period.

            Parameters:
            df (DataFrame): The input DataFrame containing the data to calculate RSI for. It is assumed to have a column
                corresponding to the specified 'column' argument.
            period (int): The look-back period to use for calculating the RSI.
            column (str, optional): The name of the column in the DataFrame from which to base RSI calculations. Defaults
                to 'close'.

            Returns:
            DataFrame: The input DataFrame with an additional column containing the computed RSI values. The new column
                is named 'rsi_<period>'.
        """
        rsi_column = f"rsi_{period}"
        if rsi_column not in df.columns:
            df[rsi_column] = pd.NA

        delta = df[column].diff(1)
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)

        avg_gain = gain.rolling(window=period, min_periods=1).mean()
        avg_loss = loss.rolling(window=period, min_periods=1).mean()

        rs = avg_gain / avg_loss
        rsi_series = 100 - (100 / (1 + rs))
        df.loc[df[rsi_column].isnull(), rsi_column] = rsi_series[df[rsi_column].isnull()]
        df[rsi_column] = df[rsi_column].round(4)
        return df

    @staticmethod
    def calculate_macd_partial(df, short_window=12, long_window=26, signal_window=9, column="close"):
        """
            Calculates and updates the MACD (Moving Average Convergence Divergence), its Signal line, and Histogram
            for the given DataFrame. It computes the values based on specified window sizes
            for short-term EMA, long-term EMA, and signal line EMA, and updates the DataFrame
            with calculated values only for rows where these columns are null.

            Args:
                df (pd.DataFrame): Pandas DataFrame containing the column used for calculations.
                short_window (int): Number of periods for the short window EMA.
                long_window (int): Number of periods for the long window EMA.
                signal_window (int): Number of periods for the signal line EMA.
                column (str): Name of the column used for calculations.

            Returns:
                pd.DataFrame: Updated DataFrame containing the computed MACD, MACD Signal,
                              and MACD Histogram values.
        """
        if "MACD" not in df.columns:
            df["MACD"] = pd.NA
        if "MACD_Signal" not in df.columns:
            df["MACD_Signal"] = pd.NA
        if "MACD_Hist" not in df.columns:
            df["MACD_Hist"] = pd.NA

        short_ema = df[column].ewm(span=short_window, adjust=False).mean()
        long_ema = df[column].ewm(span=long_window, adjust=False).mean()
        macd_series = short_ema - long_ema
        macd_signal_series = macd_series.ewm(span=signal_window, adjust=False).mean()
        macd_hist_series = macd_series - macd_signal_series

        # Rellenar solo los valores nulos
        df.loc[df["MACD"].isnull(), "MACD"] = macd_series[df["MACD"].isnull()].round(4)
        df.loc[df["MACD_Signal"].isnull(), "MACD_Signal"] = macd_signal_series[df["MACD_Signal"].isnull()].round(4)
        df.loc[df["MACD_Hist"].isnull(), "MACD_Hist"] = macd_hist_series[df["MACD_Hist"].isnull()].round(4)
        return df

    @staticmethod
    def remove_incomplete_records(df):
        """
            Removes rows marked as incomplete from a given DataFrame. This method
            specifically checks for the presence of a column named
            'is_incomplete' in the provided DataFrame. If the column exists,
            records where 'is_incomplete' is True are removed, and the column is
            subsequently dropped from the DataFrame. The number of removed
            records is printed to the console. If the column does not exist, the
            method notifies the user without making any changes to the dataset.

            Args:
                df: The pandas DataFrame to process.

            Returns:
                A pandas DataFrame with incomplete records removed if applicable.
        """
        if "is_incomplete" in df.columns:
            original_size = len(df)
            df = df[~df["is_incomplete"]].reset_index(drop=True)
            removed = original_size - len(df)
            print(f"Registros eliminados: {removed}")

            # Eliminar la columna 'is_incomplete'
            df = df.drop(columns=["is_incomplete"])
        else:
            print("La columna 'is_incomplete' no existe en el dataset. No se eliminaron registros ni columnas.")
        return df

    @staticmethod
    def split_date(df):
        """
            Splits a datetime column in a DataFrame into separate date and time components.

            This static method processes a DataFrame containing a datetime column by validating
            its presence, converting it to a valid datetime format if necessary, removing
            unnecessary columns, and creating new columns for day, month, year, and time.

            Args:
                df (pandas.DataFrame): The DataFrame containing a 'datetime' column.

            Raises:
                ValueError: If the DataFrame does not contain a 'datetime' column.

            Returns:
                pandas.DataFrame: A modified DataFrame with new columns for 'day', 'month',
                'year', and 'time' derived from the 'datetime' column.
        """
        # Verificar si datetime existe en el dataset
        if "datetime" not in df.columns:
            raise ValueError("El dataset no contiene una columna 'datetime'.")

        # Convertir datetime si no está en el formato adecuado
        df["datetime"] = pd.to_datetime(df["datetime"], errors="coerce")

        # Eliminar campos innecesarios
        df = df.drop(columns=["date", "year_month"], errors="ignore")

        # Crear nuevos campos derivados de datetime
        df["day"] = df["datetime"].dt.day
        df["month"] = df["datetime"].dt.month
        df["year"] = df["datetime"].dt.year
        df["time"] = df["datetime"].dt.hour

        return df

    @staticmethod
    def fill_missing_hours(df):
        """
            Fill missing hourly data for given days by interpolating from the first or last available hour.

            This method ensures that each day in the dataset has a full set of 24 hourly entries
            (from 00:00 to 23:00). If an hour is missing for a specific day, it fills the missing
            hour using the data from the nearest (first or last) available hour for that day.
            Additionally, it reconstructs a standardized datetime column for sorting and validation.

            Raises:
                ValueError: If the input DataFrame does not contain the required columns:
                {"year", "month", "day", "time"}.

            Args:
                df (pd.DataFrame): The input dataset containing at least the columns
                {"year", "month", "day", "time"} with other associated data.

            Returns:
                pd.DataFrame: The modified dataset with all hourly gaps filled for each day.
        """
        # Verificar que los campos necesarios existan
        required_columns = {"year", "month", "day", "time"}
        if not required_columns.issubset(df.columns):
            raise ValueError(f"El dataset debe contener las columnas: {required_columns}")

        # Generar las 24 horas para cada día
        unique_days = df[["year", "month", "day"]].drop_duplicates()

        filled_rows = []
        for year, month, day in unique_days.itertuples(index=False, name=None):
            # Filtrar los datos del día actual
            day_data = df[(df["year"] == year) & (df["month"] == month) & (df["day"] == day)]

            # Crear una lista de horas completas
            all_hours = set(range(24))
            existing_hours = set(day_data["time"].unique())

            missing_hours = sorted(all_hours - existing_hours)

            if not day_data.empty:
                # Primera y última hora del día
                first_hour_data = day_data[day_data["time"] == day_data["time"].min()].iloc[0]
                last_hour_data = day_data[day_data["time"] == day_data["time"].max()].iloc[0]

                for hour in missing_hours:
                    row = None
                    if hour < day_data["time"].min():  # Antes de la primera hora
                        row = first_hour_data.copy()
                    elif hour > day_data["time"].max():  # Después de la última hora
                        row = last_hour_data.copy()

                    if row is not None:
                        row["time"] = hour
                        filled_rows.append(row)

        # Agregar las filas rellenadas al dataset original
        if filled_rows:
            df = pd.concat([df, pd.DataFrame(filled_rows)], ignore_index=True)

        # Asegurar que 'time' sea interpretado como hora
        df["hour"] = df["time"].astype(int)

        # Reconstruir el campo 'datetime'
        df["datetime"] = pd.to_datetime(df[["year", "month", "day", "hour"]])

        # Ordenar por fecha y hora
        df = df.sort_values(by=["year", "month", "day", "hour"]).reset_index(drop=True)

        # Eliminar la columna auxiliar 'hour'
        df = df.drop(columns=["hour"])

        return df

    @staticmethod
    def fill_missing_days(df):
        """
            Static method to fill missing days in a dataset by generating rows for days not included in the dataset.
            The method interpolates based on the last available data prior to the missing day to create 24 hourly
            entries for each missing day.

            Parameters
            ----------
            df : pandas.DataFrame
                Input dataframe containing columns 'year', 'month', 'day', and 'time'.
                These columns are used to determine the missing days and generate interpolated data.

            Returns
            -------
            pandas.DataFrame
                DataFrame with the missing days filled and sorted by datetime.
                Includes modifications for rows created based on interpolated data.

            Raises
            ------
            ValueError
                If the input dataframe does not contain the required columns: 'year', 'month', 'day', 'time'.
        """
        # Verificar que los campos necesarios existan
        required_columns = {"year", "month", "day", "time"}
        if not required_columns.issubset(df.columns):
            raise ValueError(f"El dataset debe contener las columnas: {required_columns}")

        # Convertir a datetime para facilitar el manejo de fechas
        df["datetime"] = pd.to_datetime(df[["year", "month", "day"]]) + pd.to_timedelta(df["time"], unit="h")

        # Generar rango completo de fechas excluyendo el último día
        full_date_range = pd.date_range(
            start=df["datetime"].min().normalize(),
            end=df["datetime"].max().normalize() - pd.Timedelta(days=1),
            freq="D"
        )

        # Identificar días existentes
        existing_dates = df["datetime"].dt.date.unique()

        # Detectar días faltantes
        missing_dates = sorted(set(full_date_range.date) - set(existing_dates))

        # Generar filas para días faltantes
        filled_rows = []
        for missing_date in missing_dates:
            # Último día disponible antes del día faltante
            previous_day_data = df[df["datetime"].dt.date < missing_date]
            if previous_day_data.empty:
                continue

            last_day_data = previous_day_data[previous_day_data["datetime"] == previous_day_data["datetime"].max()]
            for hour in range(24):  # Generar las 24 horas para el día faltante
                row = last_day_data.iloc[0].copy()
                row["year"], row["month"], row["day"], row[
                    "time"] = missing_date.year, missing_date.month, missing_date.day, hour
                filled_rows.append(row)

        # Agregar filas generadas al dataset original
        if filled_rows:
            df = pd.concat([df, pd.DataFrame(filled_rows)], ignore_index=True)

        # Reconstruir y ordenar por 'datetime'
        df["datetime"] = pd.to_datetime(df[["year", "month", "day"]]) + pd.to_timedelta(df["time"], unit="h")
        df = df.sort_values(by=["datetime"]).reset_index(drop=True)

        return df

    @staticmethod
    def add_temporal_features(df):
        """
            Adds temporal features to a DataFrame including day of the week, weekend indication,
            and market session indicators based on NASDAQ time ranges. The method assumes
            the presence of 'datetime' and 'time' columns for computation.

            Parameters:
                df (pandas.DataFrame): The input DataFrame containing at least 'datetime' and
                'time' columns, where 'datetime' is a pandas datetime type and 'time' is a
                recognized time representation.

            Raises:
                ValueError: If the 'datetime' column is not present in the input DataFrame.

            Returns:
                pandas.DataFrame: The input DataFrame with additional columns for computed
                temporal features.
        """
        # Asegurarse de que la columna datetime existe
        if "datetime" not in df.columns:
            raise ValueError(
                "El dataset no contiene la columna 'datetime' necesaria para calcular las características temporales.")

        # Día de la semana
        df["day_of_week"] = df["datetime"].dt.dayofweek

        # Fin de semana
        df["is_weekend"] = df["day_of_week"].isin([5, 6]).astype(int)

        # Horarios de mercado según NASDAQ
        df["is_premarket"] = df["time"].between(4, 9, inclusive="both").astype(int)
        df["is_market"] = df["time"].between(10, 16, inclusive="both").astype(int)
        df["is_postmarket"] = df["time"].between(17, 20, inclusive="both").astype(int)

        # Establecer a cero los indicadores fuera de horario y en fines de semana
        df.loc[df["is_weekend"] == 1, ["is_premarket", "is_market", "is_postmarket"]] = 0
        df.loc[~df["time"].between(4, 20, inclusive="both"), ["is_premarket", "is_market", "is_postmarket"]] = 0

        return df

    def apply_advanced_features(self, df):
        """
            Processes and enhances a DataFrame by applying several advanced analytical features
            based on the given configuration. Depending on the configuration, specific indicators,
            cycle analyses, and aggregated perspectives are calculated and added to the DataFrame.

            Parameters:
            df : DataFrame
                The input DataFrame to which the advanced features are applied.

            Returns:
            DataFrame
                The transformed DataFrame with the selected advanced features added.

            Raises:
            KeyError
                Raised if any required key in the configuration dictionary is missing.
        """
        # Indicadores avanzados
        if self.config["advanced_indicators"].get("intraday_volatility", False):
            df = self.add_intraday_volatility(df)

        if self.config["advanced_indicators"].get("volume_ratio", False):
            df = self.add_volume_ratio(df)

        if self.config["advanced_indicators"].get("price_trend", False):
            df = self.add_price_trend(df)

        # Análisis de ciclos
        if self.config["cycle_analysis"].get("monthly_cycle", False):
            df = self.add_monthly_cycle(df)

        if self.config["cycle_analysis"].get("yearly_cycle", False):
            df = self.add_yearly_cycle(df)

        # Perspectiva agregada
        if self.config["aggregated_perspective"].get("closing_moving_avg", False):
            df = self.add_closing_moving_avg(df)

        if self.config["aggregated_perspective"].get("cumulative_change_in_volume", False):
            df = self.add_cumulative_change_in_volume(df)

        return df

    @staticmethod
    def add_intraday_volatility(df):
        """
            Computes the intraday volatility for each row in a DataFrame by finding the
            difference between the "high" and "low" columns and rounding the result to
            four decimal places.

            Parameters
            ----------
            df : DataFrame
                A pandas DataFrame containing at least two columns: "high" and "low".

            Returns
            -------
            DataFrame
                The same DataFrame with an added column, "intraday_volatility", containing
                the calculated volatility for each row.
        """
        df["intraday_volatility"] = (df["high"] - df["low"]).round(4)
        return df

    @staticmethod
    def add_volume_ratio(df):
        """
            This static method calculates the volume ratio for a given DataFrame and adds a new column
            named 'volume_ratio' to the DataFrame. The volume ratio is computed as the ratio of the current
            row's 'volume' to the rolling mean of 'volume' over a window of 5 periods, with a minimum of 1
            period. The result is rounded to 4 decimal places.

            Args:
                df (pandas.DataFrame): The input DataFrame containing a 'volume' column that represents
                volume values.

            Returns:
                pandas.DataFrame: A modified DataFrame with the new 'volume_ratio' column added.
        """
        df["volume_ratio"] = (df["volume"] / df["volume"].rolling(window=5, min_periods=1).mean()).round(4)
        return df

    @staticmethod
    def add_price_trend(df):
        """
            Adds a price trend column to a given DataFrame.

            This method calculates the percentage change of the 'close' prices
            in the provided DataFrame to determine the price trend. The results
            are rounded to four decimal places and added as a new column named
            'price_trend'. The modified DataFrame is then returned.

            Parameters:
            df : pandas.DataFrame
                A DataFrame that must contain a column named 'close', which
                represents the closing prices.

            Returns:
            pandas.DataFrame
                The input DataFrame with an additional 'price_trend' column.
        """
        df["price_trend"] = df["close"].pct_change().round(4)
        return df

    @staticmethod
    def add_monthly_cycle(df):
        """
            Adds a 'month_cycle' column to the DataFrame based on the 'day' column.

            This method processes the given DataFrame by creating a new column named
            'month_cycle'. The values for this column are directly taken from the
            'day' column of the DataFrame. It is intended to reflect the current
            day in the context of a monthly cycle.

            Args:
                df (DataFrame): A pandas DataFrame containing a 'day' column, which
                represents the day of the month.

            Returns:
                DataFrame: The modified DataFrame with the added 'month_cycle' column.
        """
        df["month_cycle"] = df["day"]
        return df

    @staticmethod
    def add_yearly_cycle(df):
        """
            Adds a yearly cycle column to a DataFrame.

            This static method computes the quarterly cycle of dates from
            a "datetime" column in the provided DataFrame and stores the
            result in a new "yearly_cycle" column. The method utilizes the
            pandas functionality for extracting the quarter from datetime
            values. The input DataFrame is modified in place and also
            returned.

            Args:
                df (pandas.DataFrame): The input DataFrame containing a
                    "datetime" column of datetime type.

            Returns:
                pandas.DataFrame: The same DataFrame with an added
                "yearly_cycle" column representing the quarter for each
                date.
        """
        df["yearly_cycle"] = df["datetime"].dt.quarter
        return df

    @staticmethod
    def add_closing_moving_avg(df):
        """
            Add a new column to the DataFrame containing the moving average of the closing prices over a
            specified window of 5 periods. The moving average is calculated with a rolling window,
            allowing partial averages with a minimum period of 1. The result is rounded to 4 decimal places.

            Args:
            df (pd.DataFrame): A pandas DataFrame containing a column named 'close', which represents
            closing prices.

            Returns:
            pd.DataFrame: The original DataFrame with an additional column 'closing_moving_avg'
            containing the computed moving average values.
        """
        df["closing_moving_avg"] = df["close"].rolling(window=5, min_periods=1).mean().round(4)
        return df

    @staticmethod
    def add_cumulative_change_in_volume(df):
        """
            Summarizes the functionality of adding a cumulative sum of the 'volume' column
            to the given DataFrame. A new column 'cumulative_change_in_volume' is created
            to store the cumulative sum, rounded to 4 decimal places.

            Args:
                df (pd.DataFrame): A pandas DataFrame containing a column named 'volume'.

            Returns:
                pd.DataFrame: The input DataFrame modified with an additional column
                    'cumulative_change_in_volume' containing the cumulative sum of the
                    'volume' column.
        """
        df["cumulative_change_in_volume"] = df["volume"].cumsum().round(4)
        return df
