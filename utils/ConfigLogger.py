import os
import pandas as pd
from datetime import datetime
from utils.utils import load_config, get_time_now


class ConfigLogger:
    def __init__(self, config_file='gen_dataset_config', output_dir='data'):
        """
        Represents a class constructor to initialize the configuration file path, output file
        path, and settings essential for the dataset generation process. Additionally, it
        ensures that the output directory exists.

        Attributes:
            config_file (str): Name of the configuration file. Defaults to 'gen_dataset_config'.
            output_file (str): Path to the output file storing configuration history.
            config (dict): Loaded configuration settings from the specified configuration file.

        Parameters:
            config_file (str, optional): Name of the configuration file. Defaults to 'gen_dataset_config'.
            output_dir (str, optional): Directory path to store output files. Defaults to 'data'.

        Raises:
            FileNotFoundError: If the configuration file does not exist.
        """
        self.config_file = config_file
        self.output_file = os.path.join(output_dir, 'config_history.csv')
        self.config = load_config(self.config_file)

        # Ensure the output directory exists
        os.makedirs(output_dir, exist_ok=True)

    def log_config(self):
        """
        Logs the current configuration state to a CSV file. If the file already exists, appends
        the new configuration; otherwise, creates a new file.

        Summary:
        This method is responsible for logging the current configuration of the object instance
        in a structured format (CSV). It includes appending a flattened version of the
        configuration dictionary along with the execution timestamp to the specified output file.
        The configuration is stored using pandas DataFrame and managed to ensure no data loss
        on recurring executions.

        Parameters:
        self:
            Reference to the object instance containing the configuration to be saved and the
            output file path.

        Raises:
        OSError:
            May raise an error if the file operations such as reading or writing to a file
            encounter issues, e.g., insufficient permissions or missing directories.

        Returns:
        None
        """

        # Get the current date and time
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        # Convert the configuration into a single flat dictionary
        config_flat = self.flatten_config(self.config)

        # Add the execution timestamp
        config_flat['execution_time'] = timestamp

        # Create a DataFrame with the configuration
        df = pd.DataFrame([config_flat])

        # If the file does not exist, create it; if it exists, append the new execution
        if os.path.exists(self.output_file):
            df_existing = pd.read_csv(self.output_file)
            df = pd.concat([df_existing, df], ignore_index=True)

        # Save as CSV
        df.to_csv(self.output_file, index=False, encoding='utf-8')
        print(f'{get_time_now()} :: Saving configuration: Configuration saved in {self.output_file}')

    def flatten_config(self, config, parent_key=''):
        """
        Flattens a nested dictionary by combining parent and nested keys using a
        specified separator.

        This method takes a nested dictionary and returns a new dictionary where all
        nested keys are combined with their parent keys into a single flat structure,
        separated by underscores by default. Works recursively to ensure all levels of
        nesting are flattened.

        Parameters:
            config (dict): A dictionary potentially containing nested dictionaries.
            parent_key (str): A prefix to append to keys while flattening. Defaults to
                an empty string.

        Returns:
            dict: A flat dictionary with keys generated by combining parent and child
            keys from the nested structure.
        """
        items = {}
        for k, v in config.items():
            new_key = f'{parent_key}{k}' if parent_key else k
            if isinstance(v, dict):
                items.update(self.flatten_config(v, new_key + '_'))
            else:
                items[new_key] = v
        return items